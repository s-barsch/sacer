// Code generated by go generate; DO NOT EDIT.

package entry

import (
	"fmt"
	"time"
)

func Title(e interface{}, lang string) string {
	switch e.(type) {
	case *audio.Audio:
		return e.(*audio.Audio).Title(lang)
	case *html.Html:
		return e.(*html.Html).Title(lang)
	case *image.Image:
		return e.(*image.Image).Title(lang)
	case *text.Text:
		return e.(*text.Text).Title(lang)
	case *video.Video:
		return e.(*video.Video).Title(lang)
	case *set.Set:
		return e.(*set.Set).Title(lang)
	case *hold.Hold:
		return e.(*hold.Hold).Title(lang)
	}
	return "no title: invalid entry type"
}

func Id(e interface{}) string {
	switch e.(type) {
	case *audio.Audio:
		return e.(*audio.Audio).Id()
	case *html.Html:
		return e.(*html.Html).Id()
	case *image.Image:
		return e.(*image.Image).Id()
	case *text.Text:
		return e.(*text.Text).Id()
	case *video.Video:
		return e.(*video.Video).Id()
	case *set.Set:
		return e.(*set.Set).Id()
	case *hold.Hold:
		return e.(*hold.Hold).Id()
	case *file.File:
		return e.(*file.File).Id
	}
	return "no id: invalid entry type"
}

func EntryHold(e interface{}) *Hold {
	switch e.(type) {
	case *audio.Audio:
		return e.(*audio.Audio).File.Hold
	case *html.Html:
		return e.(*html.Html).File.Hold
	case *image.Image:
		return e.(*image.Image).File.Hold
	case *text.Text:
		return e.(*text.Text).File.Hold
	case *video.Video:
		return e.(*video.Video).File.Hold
	case *set.Set:
		return e.(*set.Set).File.Hold
	case *hold.Hold:
		return e.(*hold.Hold).File.Hold
	case *file.File:
		return e.(*file.File).Hold
	}
	return nil
}

func EntryFile(e interface{}) *File {
	switch e.(type) {
	case *audio.Audio:
		return e.(*audio.Audio).File
	case *html.Html:
		return e.(*html.Html).File
	case *image.Image:
		return e.(*image.Image).File
	case *text.Text:
		return e.(*text.Text).File
	case *video.Video:
		return e.(*video.Video).File
	case *set.Set:
		return e.(*set.Set).File
	case *hold.Hold:
		return e.(*hold.Hold).File
	case *file.File:
		return e.(*file.File)
	}
	return nil
}

func EntrySection(e interface{}) string {
	file := EntryFile(e)
	if file != nil {
		return f.Section()
	}
	return "no section: invalid entry type"
}

func Type(e interface{}) string {
	switch e.(type) {
	case *audio.Audio:
		return "audio"
	case *html.Html:
		return "html"
	case *image.Image:
		return "image"
	case *text.Text:
		return "text"
	case *video.Video:
		return "video"
	case *set.Set:
		return "set"
	case *hold.Hold:
		return "hold"
	case *file.File:
		return "file"
	}
	return "no type: invalid entry type"
}

func Permalink(e interface{}, lang string) string {
	switch e.(type) {
	case *audio.Audio:
		return e.(*audio.Audio).Permalink(lang)
	case *html.Html:
		return e.(*html.Html).Permalink(lang)
	case *image.Image:
		return e.(*image.Image).Permalink(lang)
	case *text.Text:
		return e.(*text.Text).Permalink(lang)
	case *video.Video:
		return e.(*video.Video).Permalink(lang)
	case *set.Set:
		return e.(*set.Set).Permalink(lang)
	case *hold.Hold:
		return e.(*hold.Hold).Permalink(lang)
	case *file.File:
		return e.(*file.File)
	}
	return "no permalink: invalid entry type"
}

func Date(e interface{}) time.Time {
	switch e.(type) {
	case *audio.Audio:
		return e.(*audio.Audio).Date
	case *html.Html:
		return e.(*html.Html).Date
	case *image.Image:
		return e.(*image.Image).Date
	case *text.Text:
		return e.(*text.Text).Date
	case *video.Video:
		return e.(*video.Video).Date
	case *set.Set:
		return e.(*set.Set).Date
	case *hold.Hold:
		return e.(*hold.Hold).Date
	case *file.File:
		return e.(*file.File)
	}
	return time.Time{}
}

func ModTime(e interface{}) time.Time {
	switch e.(type) {
	case *audio.Audio:
		return e.(*audio.Audio).ModTime
	case *html.Html:
		return e.(*html.Html).ModTime
	case *image.Image:
		return e.(*image.Image).ModTime
	case *text.Text:
		return e.(*text.Text).ModTime
	case *video.Video:
		return e.(*video.Video).ModTime
	case *set.Set:
		return e.(*set.Set).ModTime
	case *hold.Hold:
		return e.(*hold.Hold).ModTime
	case *file.File:
		return e.(*file.File).ModTime
	}
	return time.Time{}
}

func EntryInfo(e interface{}) Info {
	switch e.(type) {
	case *audio.Audio:
		return e.(*audio.Audio).Info
	case *html.Html:
		return e.(*html.Html).Info
	case *image.Image:
		return e.(*image.Image).Info
	case *text.Text:
		return e.(*text.Text).Info
	case *video.Video:
		return e.(*video.Video).Info
	case *set.Set:
		return e.(*set.Set).Info
	case *hold.Hold:
		return e.(*hold.Hold).Info
	}
	return map[string]string{}
}

func setInfo(e interface{}, i Info) error {
	switch e.(type) {
	case *audio.Audio:
		audio.Info = i
	case *html.Html:
		html.Info = i
	case *image.Image:
		image.Info = i
	case *text.Text:
		text.Info = i
	case *video.Video:
		video.Info = i
	case *set.Set:
		set.Info = i
	case *hold.Hold:
		hold.Info = i
	default:
		return fmt.Errorf("could not set info: invalid entry type. %v", e)
	}
	return nil
}
